<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta name="description" content="Academic Webpage" />
    <meta name="author" content="Cai Songbai" />
    <title id="title">Woodman - Academic Homepage</title>

    <!-- Icon -->
    <link rel="icon" type="image/x-icon" href="static/assets/favicon.ico" />

    <!-- Bootstrap icons-->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css" rel="stylesheet" />

    <!-- Google fonts-->
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link href="https://fonts.googleapis.com/css2?family=Newsreader:ital,wght@0,600;1,600&amp;display=swap" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Mulish:ital,wght@0,300;0,500;0,600;0,700;1,300;1,500;1,600;1,700&amp;display=swap" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Kanit:ital,wght@0,400;1,400&amp;display=swap" rel="stylesheet" />

    <!-- Core theme CSS (includes Bootstrap)-->
    <link type="text/css" href="static/css/styles.css" rel="stylesheet" />
    <link type="text/css" href="static/css/main.css" rel="stylesheet" />

    <!-- Three.js Import Map (CDN) - 增加了 addons 以支持后期处理 -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- Markdown & Tools -->
    <script type="text/javascript" src="static/js/bootstrap.bundle.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script type="text/javascript" src="static/js/marked.min.js"></script>
    <script type="text/javascript" src="static/js/js-yaml.min.js"></script>

    <!-- Mathematics -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>

<body id="page-top">
    <!-- Navigation-->
    <nav class="header navbar navbar-expand-lg navbar-light fixed-top shadow-sm" id="mainNav">
        <div class="container px-5">
            <a id="page-top-title" class="navbar-brand fw-bold" href="#page-top">Woodman</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive"
                aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                MENU
                <i class="bi-list"></i>
            </button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <ul class="navbar-nav ms-auto me-4 my-3 my-lg-0">
                    <li class="nav-item"><a class="nav-link me-lg-3" href="#home">HOME</a></li>
                    <li class="nav-item"><a class="nav-link me-lg-3" href="#publications">PUBLICATIONS</a></li>
                    <li class="nav-item"><a class="nav-link me-lg-3" href="#experience">EXPERIENCE</a></li>
                    <li class="nav-item"><a class="nav-link me-lg-3" href="#awards">AWARDS</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- --- 3D Header Section --- -->
    <div id="canvas-container">
        <div class="hero-overlay">
            <!-- 文字会被 scripts.js 自动填充 -->
            <h2 id="top-section-bg-text" class="display-3 lh-1 font-alt"></h2>
        </div>
    </div>

    <!-- --- Photo Section (悬浮头像) --- -->
    <div id="avatar-container">
        <img src="static/assets/img/photo.png" alt="Cai Songbai" class="shadow">
    </div>

    <!-- Home -->
    <section class="bg-gradient-primary-to-secondary-light mt5 md5" id="home">
        <div class="container px-5">
            <header>
                <h2 id="home-subtitle"> </h2>
            </header>
            <div class="main-body" id="home-md"></div>
        </div>
    </section>

    <!-- Publications -->
    <section class="bg-gradient-primary-to-secondary-gray mt5 md5" id="publications">
        <div class="container px-5">
            <header>
                <h2 id="publications-subtitle"><i class="bi bi-file-text-fill"></i>&nbsp;PUBLICATIONS</h2>
            </header>
            <div class="main-body" id="publications-md"></div>
        </div>
    </section>

    <!-- Experience -->
    <section class="bg-gradient-primary-to-secondary-dark mt5 md5" id="experience">
        <div class="container px-5">
            <header>
                <h2 id="experience-subtitle"><i class="bi bi-briefcase-fill"></i> EXPERIENCE </h2>
            </header>
            <div class="main-body" id="experience-md"></div>
        </div>
    </section>

    <!-- Awards -->
    <section class="bg-gradient-primary-to-secondary-light mt5 md5" id="awards">
        <div class="container px-5">
            <header>
                <h2 id="awards-subtitle"><i class="bi bi-award-fill"></i>AWARDS </h2>
            </header>
            <div class="main-body" id="awards-md"></div>
        </div>
    </section>

    <!-- Footer-->
    <footer class="bg-bottom text-center py-5">
        <div class="container px-5">
            <div class="text-white-50 small">
                <div id="copyright-text" class="mb-2"></div>
                <a id="github-link" href="https://github.com/Woodman718">Github</a>
            </div>
        </div>
    </footer>

    <!-- Core JS -->
    <script type="text/javascript" src="static/js/scripts.js"></script>

    <!-- --- Awwwards Level WebGL Logic --- -->
    <script type="module">
        import * as THREE from 'three';
        // 引入后期处理模块 (Post-processing)
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // 1. 配置
        const bgImageURL = 'static/assets/img/background2.jpeg'; 
        const container = document.getElementById('canvas-container');
        
        // 2. 场景初始化
        const scene = new THREE.Scene();
        // 透视摄像机
        const camera = new THREE.PerspectiveCamera(70, container.clientWidth / container.clientHeight, 0.01, 100);
        camera.position.z = 1; // 摄像机距离平面的距离

        const renderer = new THREE.WebGLRenderer({ 
            antialias: false, // 关闭原生抗锯齿，交给 Post-processing
            alpha: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // 电影级色调映射
        renderer.toneMappingExposure = 1.2;
        container.appendChild(renderer.domElement);

        // 3. 后期处理管道 (Bloom Effect)
        const renderScene = new RenderPass(scene, camera);
        
        // Bloom 参数: 分辨率, 强度, 半径, 阈值
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(container.clientWidth, container.clientHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1; // 亮度超过这个值的像素发光
        bloomPass.strength = 0.6;  // 发光强度 (可以调高)
        bloomPass.radius = 0.5;    // 发光半径

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // 4. 自定义 Shader (支持 Cover 缩放 + 液态 + 色散)
        const vertexShader = `
            uniform float uTime;
            uniform vec2 uMouse;
            uniform vec2 uResolution;
            varying vec2 vUv;
            varying float vWave;

            void main() {
                vUv = uv;
                vec3 pos = position;

                // 将 UV 坐标转换为相对于屏幕中心的坐标 (-1 到 1)
                // 这样可以计算真正的物理距离
                float aspect = uResolution.x / uResolution.y;
                vec2 aspectUV = (uv - 0.5) * vec2(aspect, 1.0);
                vec2 mouseAspect = (uMouse - 0.5) * vec2(aspect, 1.0);

                float dist = distance(aspectUV, mouseAspect);
                
                // 鼠标涟漪衰减
                float decay = clamp(1.0 - dist * 1.5, 0.0, 1.0);
                
                // 复杂的液态波浪算法 (叠加多个正弦波)
                float wave1 = sin(uv.x * 4.0 + uTime * 0.5);
                float wave2 = sin(uv.y * 6.0 + uTime * 0.8);
                float mouseWave = sin(dist * 20.0 - uTime * 8.0) * 0.1 * decay;

                // 将波浪应用到 Z 轴，让图片有起伏
                pos.z += (wave1 * wave2) * 0.05 + mouseWave;
                
                vWave = mouseWave; // 传递给片元着色器用于色散

                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const fragmentShader = `
            uniform sampler2D uTexture;
            uniform vec2 uImageRes;
            uniform vec2 uContainerRes;
            varying vec2 vUv;
            varying float vWave;

            // --- 核心算法：模拟 background-size: cover ---
            vec2 getCoverUv(vec2 uv) {
                vec2 s = uContainerRes; // Screen resolution
                vec2 i = uImageRes;     // Image resolution
                
                float rs = s.x / s.y;
                float ri = i.x / i.y;
                
                vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);
                vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;
                
                return uv * s / new + offset;
            }

            void main() {
                vec2 uv = getCoverUv(vUv);

                // 简单的边界检查，防止缩放后边缘拉伸
                if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
                    discard; 
                }

                // RGB Shift (色散故障效果)
                // 基于 vWave (鼠标交互强度) 偏移 RGB 通道
                float shiftStrength = 0.03 + vWave * 0.2; 
                
                float r = texture2D(uTexture, uv + vec2(shiftStrength, 0.0)).r;
                float g = texture2D(uTexture, uv).g;
                float b = texture2D(uTexture, uv - vec2(shiftStrength, 0.0)).b;

                // 增加一点对比度
                vec3 color = vec3(r, g, b);
                
                // 稍微调暗一点，让上面的白色文字更清晰，同时让 Bloom 更有层次
                gl_FragColor = vec4(color * 0.9, 1.0);
            }
        `;

        // 5. 加载资源并创建物体
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load(bgImageURL, (texture) => {
            
            // 必须设置纹理过滤，防止缩放锯齿
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;

            // 创建一个填满摄像机视角的平面
            // 2x2 的平面在 z=0, camera z=1, fov=70 左右时需要微调，或者直接计算视口大小
            // 这里我们用一个足够大的平面，依靠 Shader 裁剪
            const geometry = new THREE.PlaneGeometry(4, 4, 64, 64); // 64x64 细分以支持波浪
            
            const material = new THREE.ShaderMaterial({
                vertexShader,
                fragmentShader,
                uniforms: {
                    uTime: { value: 0 },
                    uMouse: { value: new THREE.Vector2(0.5, 0.5) },
                    uTexture: { value: texture },
                    uImageRes: { value: new THREE.Vector2(texture.image.width, texture.image.height) },
                    uContainerRes: { value: new THREE.Vector2(container.clientWidth, container.clientHeight) },
                    uResolution: { value: new THREE.Vector2(container.clientWidth, container.clientHeight) }
                }
            });

            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            // 6. 交互逻辑
            const clock = new THREE.Clock();
            let targetMouse = new THREE.Vector2(0.5, 0.5);
            let currentMouse = new THREE.Vector2(0.5, 0.5);

            document.addEventListener('mousemove', (e) => {
                const rect = container.getBoundingClientRect();
                if (e.clientY <= rect.bottom + 100) {
                    // 将鼠标坐标映射到 0-1 空间
                    targetMouse.x = (e.clientX - rect.left) / rect.width;
                    targetMouse.y = 1.0 - (e.clientY - rect.top) / rect.height;
                }
            });

            function animate() {
                requestAnimationFrame(animate);
                
                const time = clock.getElapsedTime();
                material.uniforms.uTime.value = time;

                // 鼠标平滑插值 (Lerp)
                currentMouse.x += (targetMouse.x - currentMouse.x) * 0.05;
                currentMouse.y += (targetMouse.y - currentMouse.y) * 0.05;
                material.uniforms.uMouse.value = currentMouse;

                // 使用 composer 渲染 (包含辉光)
                composer.render();
            }
            animate();

            // 7. 响应式处理 (修复缩放问题的关键)
            window.addEventListener('resize', () => {
                const w = container.clientWidth;
                const h = container.clientHeight;
                
                renderer.setSize(w, h);
                composer.setSize(w, h);
                
                camera.aspect = w / h;
                camera.updateProjectionMatrix();

                // 更新 Shader 中的屏幕分辨率，重新计算 Cover 比例
                material.uniforms.uContainerRes.value.set(w, h);
                material.uniforms.uResolution.value.set(w, h);
            });
        });
    </script>
</body>
</html>
